<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Life Tree</title>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <style>
        .node circle {
            fill: #999;
            cursor: pointer;
        }
        .node text {
            font: 12px sans-serif;
        }
        .link {
            fill: none;
            stroke: #555;
            stroke-width: 1.5px;
        }
    </style>
</head>
<body>
    <svg width="100%" height="100%"></svg>
    <script>
        const margin = {top: 20, right: 120, bottom: 20, left: 120};
        const width = 1200 - margin.right - margin.left;
        const height = 1200 - margin.top - margin.bottom;

        const svg = d3.select("svg")
            .attr("width", width + margin.right + margin.left)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        const zoom = d3.zoom()
            .scaleExtent([0.5, 5])
            .on("zoom", (event) => {
                svg.attr("transform", event.transform);
            });

        d3.select("svg").call(zoom);

        async function fetchTaxa() {
            const response = await fetch('https://api.inaturalist.org/v1/taxa?page=all&per_page=10000');
            const data = await response.json();
            return data.results;
        }

        async function drawTree() {
            const taxa = await fetchTaxa();

            const root = d3.stratify()
                .id(d => d.id)
                .parentId(d => d.parent_id)
                (taxa);

            root.each(d => {
                if (d.depth === 1) {
                    d._children = d.children;
                    d.children = null; // Hide children of "Animalia", "Plantae", etc.
                } else if (d.depth > 1) {
                    d._children = d.children;
                    d.children = null; // Hide all other children initially
                }
            });

            const treeLayout = d3.tree().size([height, width]).nodeSize([50, 200]);
            treeLayout(root);

            update(root);

            function update(source) {
                const nodes = root.descendants().reverse();
                const links = root.links();

                treeLayout(root);

                const node = svg.selectAll(".node")
                    .data(nodes, d => d.id || (d.id = ++i));

                const nodeEnter = node.enter().append("g")
                    .attr("class", "node")
                    .attr("transform", d => `translate(${source.y0},${source.x0})`)
                    .on("click", click);

                nodeEnter.append("circle")
                    .attr("r", 4.5);

                nodeEnter.append("text")
                    .attr("dy", 3)
                    .attr("x", d => d.children || d._children ? -10 : 10)
                    .style("text-anchor", d => d.children || d._children ? "end" : "start")
                    .text(d => `${d.data.name} (${d.data.rank})`);

                const nodeUpdate = nodeEnter.merge(node);

                nodeUpdate.transition()
                    .duration(750)
                    .attr("transform", d => `translate(${d.y},${d.x})`);

                const nodeExit = node.exit().transition()
                    .duration(750)
                    .attr("transform", d => `translate(${source.y},${source.x})`)
                    .remove();

                nodeExit.select("circle")
                    .attr("r", 1e-6);

                nodeExit.select("text")
                    .style("fill-opacity", 1e-6);

                const link = svg.selectAll(".link")
                    .data(links, d => d.target.id);

                const linkEnter = link.enter().insert("path", "g")
                    .attr("class", "link")
                    .attr("d", d => {
                        const o = {x: source.x0, y: source.y0};
                        return diagonal(o, o);
                    });

                const linkUpdate = linkEnter.merge(link);

                linkUpdate.transition()
                    .duration(750)
                    .attr("d", d => diagonal(d.source, d.target));

                const linkExit = link.exit().transition()
                    .duration(750)
                    .attr("d", d => {
                        const o = {x: source.x, y: source.y};
                        return diagonal(o, o);
                    })
                    .remove();

                nodes.forEach(d => {
                    d.x0 = d.x;
                    d.y0 = d.y;
                });

                function diagonal(s, d) {
                    return `M ${s.y} ${s.x}
                            C ${(s.y + d.y) / 2} ${s.x},
                              ${(s.y + d.y) / 2} ${d.x},
                              ${d.y} ${d.x}`;
                }

                function click(event, d) {
                    if (d.data.rank === 'genus' || d.data.rank === 'species') {
                        window.location.href = `/taxa/${d.id}`; // Redirect to the genus or species page
                    } else {
                        if (d.children) {
                            d._children = d.children;
                            d.children = null;
                        } else {
                            d.children = d._children;
                            d._children = null;
                        }
                        update(d);
                    }
                }
            }
        }

        drawTree();
    </script>
</body>
</html>
